---
layout: default
title: Microservices auf Commodity Hardware Teil 7 - Service Orchestrierung
shortTitle: Microservices und Commodity Hardware Teil 7
documentationExpanded: false
comments: true
postsExpanded: true
categories: microservices spring-boot distributed-systems
published: true
excerpt: excerpt
root: ../../
---

= Service Orchestrierung

Im den letzten Kapiteln haben wir den erstern Service _billy_time_ gebaut, deployt und in die Infrastruktur integriert. Der Service wird überwacht und liefert momentan nichts weiter als eine statische Projektliste zurück, auf die wir irgendwann unsere Zeiten buchen wollen. In diesem Kapitel werden wir das Portfolio um einen weiteren Service erweitern und zwar den echten Projekt-Service. Dieser Service verwaltet eine Liste von aktuellen und vergangenen Projekten mit Laufzeit, eingesetzten Technologien und Kunden.

Die beiden Services kommunizieren miteinander, da _billy-time_ eine aktuelle Liste von Projekten benötigt, um darauf Zeiten buchen und verwalten zu können. Natürlich könnten wir eine Punkt-zu-Punkt Verbindung (beispielsweise via REST) zwischen den Services etablieren, damit koppeln wir die beiden Services allerdings relativ eng aneinander, denn der Time-Service kann nicht mehr funktionieren, wenn der Projekt-Service nicht verfügbar ist.
Besser wäre es, die beiden Services könnten unabhängig voneinander betrieben werden. Welche Möglichkeiten wir hierfür haben evaluieren wir später im Artikel.

Auf Projekte können Zeiten gebucht werden und ich als Freelancer kann zu jeder Zeit in beliebig vielen Projekten aktiv sein.

Die Zielarchitektur der beiden Services könnte so aussehen.

image::/assets/images/07_components.png[Komponenten, 800]

Beide Services werden als Container in einem oder mehreren Docker-Hosts deployt. Die Services werden hierbei von Docker selbst orchestriert. Die Idee ist, dass wir nur definieren, was der Zielzustand ist und Docker kümmert sich darum, diesen Zielzustand so vollständig wie möglich umzusetzen.

Wir legen also beispielsweise fest, dass wir jeweils eine Instanz des _billy_time_ und eine Instanz des _billy_project_-Services brauchen. Genauso brauchen wir eine oder mehrere Instanzen einer Datenbank, um die Service-Daten zu persistieren. Auf welchen Hosts diese Services deployt werden ist allein die Aufgabe von Docker und wir müssen uns nicht weiter darum kümmern.

Die Komponente in Docker die sich um das Scheduling und die Orchestrierung der Services kümmert ist _Docker Swarm_. Vor Docker 1.12 war es zwingend nötig, Docker Swarm als separaten Container als sogenannten Agent auf jedem Host zu deployen. Seit Docker 1.12 ist Swarm in Docker integriert und kann direkt verwendet werden.


=== Docker Swarm

Docker Swarm ist die seit Docker 1.12 eingebaute Container-Orchestrierung, die es uns erlaubt, von der _echten_ Hardware zu abstrahieren.

Um einen neuen Schwarm zu initialisieren war vor Docker 1.12 ein separater Container auf jedem Node notwendig, um Swarm-Manager und Swarm-Agents zu deployen. Über den Swarm-Manager ist es möglich, Docker anzuweisen, einen Container einer bestimmten Version auf einer beliebigen vefügbaren Hardware im Swarm zu deployen.

Innerhalb eines Schwarm gibt es Manager und Worker. Der erste Knoten in einem Schwarm ist automatisch ein Manager des Schwarms. Jeder Schwarm kann beliebig viele Worker und oder Manager beinhalten.

[source, bash]
----
docker swarm init
Swarm initialized: current node (cztrjrbeplmg6p8g2ygknh2nr) is now a manager.
----

Die IP, die der Schwarm verwendet ist auch konfigurierbar über die Paramter *--advertise-addr* und *--listen-addr*.

[source, bash]
----
docker swarm init --advertise-addr=192.168.178.25 --listen-addr=192.168.178.25:2377
----

Um dem Schwarm beizutreten braucht ein weiterer Knoten nichts als den Token, den der Swarm-Manager initial erstellt und ausgegeben hat. Der Token ist quasi ein minimales Sicherheitsfeature, damit nicht einfach beliebige Knoten dem Schwarm beitreten können.

Um den Token eines Schwarm erneut ausgeben zu lassen benötigt man Zugriff auf einen beliebigen Schwarm-Knoten.

[source, bash]
----
docker swarm join-token -q worker
----

Dem Schwarm beizutreten ist jetzt ganz einfach.

[source, bash]
----
 docker swarm join --token SWMTKN-1-1jwwajxgma3lvt01ryrnzmckgu2mvu8ngoc4bd5zl7kgznuy5f-cu7r23lggmcy2qfckdl0mqh3b 192.168.178.25:2377
----

Jeder Manager im Schwarm weiß zu jeder Zeit, welche Knoten im Schwarm verfügbar sind.

[source, bash]
----
docker node ls
ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
06jf5t6jdl4t315zfrioyubni    pi48      Ready   Active
15l9pwwu9fbktb281roji4cju *  pi25      Ready   Active        Leader
----

Die beiden Knoten im Schwarm laufen auf physikalisch getrennten Maschinen, trotzdem muss es möglich sein, dass sich die Container miteinander unterhalten. Hierfür können wir ein sogenanntes Overlay-Netzwerk verwenden, dass über Host-Grenzen hinweg besteht.

Früher waren für derartige Netzwerk-Operationen mächtige Tools wie http://weave.works[Weave] notwendig. Mittlerweile wird Multi-Host Networking nativ unterstützt.

Ein neues Netzwerk zu erstellen ist sehr einfach.

[source, bash]
----
docker network create --driver overlay billy

NETWORK ID          NAME                DRIVER              SCOPE
5jxjnm2nkvwd        billy               overlay             swarm
2f29f9bcc01b        bridge              bridge              local
bef2a55e1e19        docker_gwbridge     bridge              local
b7444673a4a1        host                host                local
elahurx4yc4p        ingress             overlay             swarm
30cca23f6f43        none                null                local
----


